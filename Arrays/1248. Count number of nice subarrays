--------------using prefixsum + hashmap-----------
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        l = 0
        longest = 0
        sett = set()
        n = len(s)

        for r in range (n):
            while s[r] in sett:
                sett.remove(s[l])
                l += 1

            w = (r - l)+1
            longest = max(longest, w)
            sett.add(s[r])

        return longest

-----------backtracking + sliding window------------------------

class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        def atMost(x):
            if x < 0:
                return 0
            l = 0
            count = 0
            odd = 0

            for r in range(len(nums)):
                if nums[r] % 2:  # odd number → count as 1
                    odd += 1

                # shrink window until odd ≤ x
                while odd > x:
                    if nums[l] % 2:
                        odd -= 1
                    l += 1

                # all subarrays ending at r and starting from [l..r] are valid
                count += (r - l + 1)
            return count

        return atMost(k) - atMost(k - 1)
